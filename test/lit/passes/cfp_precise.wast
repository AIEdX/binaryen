;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt --nominal --remove-unused-names --cfp -all -S -o - | filecheck %s
;; (remove-unused-names is added to test fallthrough values without a block
;; name getting in the way)

(module
  ;; A function type that receives |this| and returns an i32.
  ;; CHECK:      (type $parent (struct (field (ref $parent.vtable))))

  ;; CHECK:      (type $parent.vtable (struct (field (ref $func))))

  ;; CHECK:      (type $func (func (param anyref) (result i32)))
  (type $func (func (param anyref) (result i32)))

  ;; A parent struct type, with a vtable.
  (type $parent (struct (field (ref $parent.vtable))))
  (type $parent.vtable (struct (field (ref $func))))

  ;; A child struct type that extends the parent. It adds a field to both the
  ;; struct and its vtable.
  ;; CHECK:      (type $child.vtable (struct (field (ref $func)) (field (ref $func))) (extends $parent.vtable))

  ;; CHECK:      (type $none_=>_anyref (func (result anyref)))

  ;; CHECK:      (type $child (struct (field (ref $child.vtable)) (field i32)) (extends $parent))
  (type $child (struct (field (ref $child.vtable)) (field i32)) (extends $parent))
  (type $child.vtable (struct (field (ref $func)) (field (ref $func)))  (extends $parent.vtable))

  ;; Keep a creation of the parent alive, so that we do not end up with no
  ;; creations and a simpler problem to solve.
  ;; CHECK:      (type $none_=>_i32 (func (result i32)))

  ;; CHECK:      (elem declare func $child.func $parent.func)

  ;; CHECK:      (export "keepalive-parent" (func $keepalive-parent))

  ;; CHECK:      (export "keepalive-child" (func $keepalive-child))

  ;; CHECK:      (export "parent" (func $create-parent-call-parent))

  ;; CHECK:      (export "child" (func $create-child-call-parent))

  ;; CHECK:      (func $keepalive-parent (result anyref)
  ;; CHECK-NEXT:  (struct.new_with_rtt $parent
  ;; CHECK-NEXT:   (struct.new_with_rtt $parent.vtable
  ;; CHECK-NEXT:    (ref.func $parent.func)
  ;; CHECK-NEXT:    (rtt.canon $parent.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (rtt.canon $parent)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $keepalive-parent (export "keepalive-parent") (result anyref)
    (struct.new_with_rtt $parent
      (struct.new_with_rtt $parent.vtable
        (ref.func $parent.func)
        (rtt.canon $parent.vtable)
      )
      (rtt.canon $parent)
    )
  )

  ;; Same as above, but for the child.
  ;; CHECK:      (func $keepalive-child (result anyref)
  ;; CHECK-NEXT:  (struct.new_with_rtt $child
  ;; CHECK-NEXT:   (struct.new_with_rtt $child.vtable
  ;; CHECK-NEXT:    (ref.func $child.func)
  ;; CHECK-NEXT:    (ref.func $child.func)
  ;; CHECK-NEXT:    (rtt.canon $child.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 9999)
  ;; CHECK-NEXT:   (rtt.canon $child)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $keepalive-child (export "keepalive-child") (result anyref)
    (struct.new_with_rtt $child
      (struct.new_with_rtt $child.vtable
        (ref.func $child.func)
        (ref.func $child.func)
        (rtt.canon $child.vtable)
      )
      (i32.const 9999)
      (rtt.canon $child)
    )
  )

  ;; CHECK:      (func $parent.func (param $this anyref) (result i32)
  ;; CHECK-NEXT:  (i32.const 128)
  ;; CHECK-NEXT: )
  (func $parent.func (param $this anyref) (result i32)
    (i32.const 128)
  )

  ;; CHECK:      (func $child.func (param $this anyref) (result i32)
  ;; CHECK-NEXT:  (i32.const 4096)
  ;; CHECK-NEXT: )
  (func $child.func (param $this anyref) (result i32)
    (i32.const 4096)
  )

  ;; CHECK:      (func $create-parent-call-parent (result i32)
  ;; CHECK-NEXT:  (local $x (ref null $parent))
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new_with_rtt $parent
  ;; CHECK-NEXT:    (struct.new_with_rtt $parent.vtable
  ;; CHECK-NEXT:     (ref.func $parent.func)
  ;; CHECK-NEXT:     (rtt.canon $parent.vtable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (rtt.canon $parent)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (i32.add
  ;; CHECK-NEXT:   (call_ref
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (struct.get $parent.vtable 0
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $x)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (call_ref
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (struct.get $parent.vtable 0
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $x)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create-parent-call-parent (export "parent") (result i32)
    (local $x (ref null $parent))

    ;; Create a parent.
    (local.set $x
      (struct.new_with_rtt $parent
        (struct.new_with_rtt $parent.vtable
          (ref.func $parent.func)
          (rtt.canon $parent.vtable)
        )
        (rtt.canon $parent)
      )
    )

    ;; Call it a few times. We should be able to infer that the local contains
    ;; exactly a parent instance and not its subtype, and so we can devirtualize
    ;; the call and inline it. This depends on escape analysis (heap2local) to
    ;; turn the struct values into locals.
    (i32.add
      (call_ref
        (local.get $x)
        (struct.get $parent.vtable 0
          (struct.get $parent 0
            (local.get $x)
          )
        )
      )
      (call_ref
        (local.get $x)
        (struct.get $parent.vtable 0
          (struct.get $parent 0
            (local.get $x)
          )
        )
      )
    )
  )

  ;; CHECK:      (func $create-child-call-parent (result i32)
  ;; CHECK-NEXT:  (local $x (ref null $parent))
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new_with_rtt $child
  ;; CHECK-NEXT:    (struct.new_with_rtt $child.vtable
  ;; CHECK-NEXT:     (ref.func $child.func)
  ;; CHECK-NEXT:     (ref.func $child.func)
  ;; CHECK-NEXT:     (rtt.canon $child.vtable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 42)
  ;; CHECK-NEXT:    (rtt.canon $child)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (i32.add
  ;; CHECK-NEXT:   (call_ref
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (struct.get $parent.vtable 0
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $x)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (call_ref
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (struct.get $parent.vtable 0
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $x)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create-child-call-parent (export "child") (result i32)
    (local $x (ref null $parent))

    ;; Create a child instance, but save it to a parent local.
    (local.set $x
      (struct.new_with_rtt $child
        (struct.new_with_rtt $child.vtable
          (ref.func $child.func)
          (ref.func $child.func)
          (rtt.canon $child.vtable)
        )
        (i32.const 42)
        (rtt.canon $child)
      )
    )

    ;; Call the method. As the local is of the parent, this seems like it could
    ;; call either the parent or the child func, but locally we know that only
    ;; a child can be in this local.
    ;;
    ;; Call it twice to verify we can optimize more than a single call.
    (i32.add
      (call_ref
        (local.get $x)
        (struct.get $parent.vtable 0
          (struct.get $parent 0
            (local.get $x)
          )
        )
      )
      (call_ref
        (local.get $x)
        (struct.get $parent.vtable 0
          (struct.get $parent 0
            (local.get $x)
          )
        )
      )
    )
  )
)
