;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt --nominal --remove-unused-names --cfp -all -S -o - | filecheck %s
;; (remove-unused-names is added to test fallthrough values without a block
;; name getting in the way)

;; This file contains tests for ConstantFieldPropagation when it uses local
;; information in order to optimize struct.gets to constant values.

(module
  ;; CHECK:      (type $struct (struct (field i32)))
  (type $struct.A (struct (ref $table.A)))
  (type $table.A (struct (ref $A)))
  (type $A (struct i32))

  (type $struct.B (struct (field (ref $table.B)) (field f32)) (extends $struct.A))
  (type $table.B (struct (ref $B) f64) (extends $table.A))
  (type $B (struct i32 i64) (extends $A))

  (func $test
    (local $a (ref null $struct.A))
    ;; Create a struct.B, but store it to a local of the parent type.
    (local.set $a
      (struct.new_with_rtt $struct.B
        (struct.new_with_rtt $table.B
          (struct.new_with_rtt $B
            (i32.const 1)
            (i64.const 2)
            (rtt.canon $B)
          )
          (f64.const 2.71828)
          (rtt.canon $table.B)
        )
        (f32.const 3.14159)
        (rtt.canon $struct.B)
      )
    )
    (drop
      ;; While we get using the type struct.A, the local's actual value is a
      ;; reference to a struct.B, which we can infer, and so forth down the
      ;; chain til we can get a constant value at the end, as the type B always
      ;; has the same constant written to it in the whole program
      (struct.get $A 0
        (struct.get $table.A 0
          (struct.get $struct.A 0
            (local.get $a)
          )
        )
      )
    )
  )

  (func $support
    ;; Create instances of all the structs here, so that the problem is not
    ;; trivial enough to solve without local information in $test
    (drop
      (struct.new_with_rtt $struct.A
        (ref.as_non_null (ref.null $table.A))
        (rtt.canon $struct.A)
      )
      (struct.new_with_rtt $table.A
        (ref.as_non_null (ref.null $A))
        (rtt.canon $table.A)
      )
      (struct.new_with_rtt $A
        (i32.const 300)
        (rtt.canon $A)
      )
    )
    (drop
      (struct.new_with_rtt $struct.B
        (ref.as_non_null (ref.null $table.B))
        (f32.const 100)
        (rtt.canon $struct.B)
      )
      (struct.new_with_rtt $table.B
        (ref.as_non_null (ref.null $B))
        (f64.const 200)
        (rtt.canon $table.B)
      )
      (struct.new_with_rtt $B
        (i32.const 1) ;; This is the same as earlier, see previous comment.
        (i64.const 400)
        (rtt.canon $B)
      )
    )
  )
)





(module
  ;; CHECK:      (type $struct (struct (field i32)))
  (type $parent (struct i32))
  (type $child (struct i32 i64) (extends $parent))
  (type $grandchild (struct i32 i64 f32) (extends $child))

  (func $test
    (drop
      (struct.new_with_rtt $parent
        (i32.const 42)
        (rtt.canon $parent)
      )
    )
    (drop
      (struct.get $parent 0
        (ref.null $parent)
      )
    )
  )
)

(module
  ;; A function type that receives |this| and returns an i32.
  ;; CHECK:      (type $parent (struct (field (ref $parent.vtable))))

  ;; CHECK:      (type $parent.vtable (struct (field (ref $func))))

  ;; CHECK:      (type $func (func (param anyref) (result i32)))
  (type $func (func (param anyref) (result i32)))

  ;; A parent struct type, with a vtable.
  (type $parent (struct (field (ref $parent.vtable))))
  (type $parent.vtable (struct (field (ref $func))))

  ;; A child struct type that extends the parent. It adds a field to both the
  ;; struct and its vtable.
  ;; CHECK:      (type $child.vtable (struct (field (ref $func)) (field (ref $func))) (extends $parent.vtable))

  ;; CHECK:      (type $none_=>_anyref (func (result anyref)))

  ;; CHECK:      (type $child (struct (field (ref $child.vtable)) (field i32)) (extends $parent))
  (type $child (struct (field (ref $child.vtable)) (field i32)) (extends $parent))
  (type $child.vtable (struct (field (ref $func)) (field (ref $func)))  (extends $parent.vtable))

  ;; Keep a creation of the parent alive, so that we do not end up with no
  ;; creations and a simpler problem to solve.
  ;; CHECK:      (type $none_=>_i32 (func (result i32)))

  ;; CHECK:      (elem declare func $child.func $parent.func)

  ;; CHECK:      (export "keepalive-parent" (func $keepalive-parent))

  ;; CHECK:      (export "keepalive-child" (func $keepalive-child))

  ;; CHECK:      (export "parent" (func $create-parent-call-parent))

  ;; CHECK:      (export "child" (func $create-child-call-parent))

  ;; CHECK:      (func $keepalive-parent (result anyref)
  ;; CHECK-NEXT:  (struct.new_with_rtt $parent
  ;; CHECK-NEXT:   (struct.new_with_rtt $parent.vtable
  ;; CHECK-NEXT:    (ref.func $parent.func)
  ;; CHECK-NEXT:    (rtt.canon $parent.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (rtt.canon $parent)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $keepalive-parent (export "keepalive-parent") (result anyref)
    (struct.new_with_rtt $parent
      (struct.new_with_rtt $parent.vtable
        (ref.func $parent.func)
        (rtt.canon $parent.vtable)
      )
      (rtt.canon $parent)
    )
  )

  ;; Same as above, but for the child.
  ;; CHECK:      (func $keepalive-child (result anyref)
  ;; CHECK-NEXT:  (struct.new_with_rtt $child
  ;; CHECK-NEXT:   (struct.new_with_rtt $child.vtable
  ;; CHECK-NEXT:    (ref.func $child.func)
  ;; CHECK-NEXT:    (ref.func $child.func)
  ;; CHECK-NEXT:    (rtt.canon $child.vtable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 9999)
  ;; CHECK-NEXT:   (rtt.canon $child)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $keepalive-child (export "keepalive-child") (result anyref)
    (struct.new_with_rtt $child
      (struct.new_with_rtt $child.vtable
        (ref.func $child.func)
        (ref.func $child.func)
        (rtt.canon $child.vtable)
      )
      (i32.const 9999)
      (rtt.canon $child)
    )
  )

  ;; CHECK:      (func $parent.func (param $this anyref) (result i32)
  ;; CHECK-NEXT:  (i32.const 128)
  ;; CHECK-NEXT: )
  (func $parent.func (param $this anyref) (result i32)
    (i32.const 128)
  )

  ;; CHECK:      (func $child.func (param $this anyref) (result i32)
  ;; CHECK-NEXT:  (i32.const 4096)
  ;; CHECK-NEXT: )
  (func $child.func (param $this anyref) (result i32)
    (i32.const 4096)
  )

  ;; CHECK:      (func $create-parent-call-parent (result i32)
  ;; CHECK-NEXT:  (local $x (ref null $parent))
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new_with_rtt $parent
  ;; CHECK-NEXT:    (struct.new_with_rtt $parent.vtable
  ;; CHECK-NEXT:     (ref.func $parent.func)
  ;; CHECK-NEXT:     (rtt.canon $parent.vtable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (rtt.canon $parent)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (i32.add
  ;; CHECK-NEXT:   (call_ref
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (struct.get $parent.vtable 0
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $x)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (call_ref
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (struct.get $parent.vtable 0
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $x)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create-parent-call-parent (export "parent") (result i32)
    (local $x (ref null $parent))

    ;; Create a parent.
    (local.set $x
      (struct.new_with_rtt $parent
        (struct.new_with_rtt $parent.vtable
          (ref.func $parent.func)
          (rtt.canon $parent.vtable)
        )
        (rtt.canon $parent)
      )
    )

    ;; Call it a few times. We should be able to infer that the local contains
    ;; exactly a parent instance and not its subtype, and so we can devirtualize
    ;; the call and inline it. This depends on escape analysis (heap2local) to
    ;; turn the struct values into locals.
    (i32.add
      (call_ref
        (local.get $x)
        (struct.get $parent.vtable 0
          (struct.get $parent 0
            (local.get $x)
          )
        )
      )
      (call_ref
        (local.get $x)
        (struct.get $parent.vtable 0
          (struct.get $parent 0
            (local.get $x)
          )
        )
      )
    )
  )

  ;; CHECK:      (func $create-child-call-parent (result i32)
  ;; CHECK-NEXT:  (local $x (ref null $parent))
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new_with_rtt $child
  ;; CHECK-NEXT:    (struct.new_with_rtt $child.vtable
  ;; CHECK-NEXT:     (ref.func $child.func)
  ;; CHECK-NEXT:     (ref.func $child.func)
  ;; CHECK-NEXT:     (rtt.canon $child.vtable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 42)
  ;; CHECK-NEXT:    (rtt.canon $child)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (i32.add
  ;; CHECK-NEXT:   (call_ref
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (struct.get $parent.vtable 0
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $x)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (call_ref
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (struct.get $parent.vtable 0
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $x)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $create-child-call-parent (export "child") (result i32)
    (local $x (ref null $parent))

    ;; Create a child instance, but save it to a parent local.
    (local.set $x
      (struct.new_with_rtt $child
        (struct.new_with_rtt $child.vtable
          (ref.func $child.func)
          (ref.func $child.func)
          (rtt.canon $child.vtable)
        )
        (i32.const 42)
        (rtt.canon $child)
      )
    )

    ;; Call the method. As the local is of the parent, this seems like it could
    ;; call either the parent or the child func, but locally we know that only
    ;; a child can be in this local.
    ;;
    ;; Call it twice to verify we can optimize more than a single call.
    (i32.add
      (call_ref
        (local.get $x)
        (struct.get $parent.vtable 0
          (struct.get $parent 0
            (local.get $x)
          )
        )
      )
      (call_ref
        (local.get $x)
        (struct.get $parent.vtable 0
          (struct.get $parent 0
            (local.get $x)
          )
        )
      )
    )
  )
)
